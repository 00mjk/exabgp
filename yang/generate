#!/usr/bin/env python3

import re
import os
import sys
import json
import shutil
import pprint
import urllib.request
from glob import glob

from pygments.token import Token
from yanglexer import yanglexer


DEBUG = True


def write(string):
    if not string.startswith('\n'):
        fill = ' ' * shutil.get_terminal_size().columns
        sys.stdout.write(f'\r{fill}\r')
    sys.stdout.write(f'{string}')
    sys.stdout.flush()


class yang:
    types = (
        'binary',
        'bits',
        'boolean',
        'decimal64',
        'empty',
        'enumeration',
        'identityref',
        'instance-identifier',
        'int8',
        'int16',
        'int32',
        'int64',
        'leafref',
        'string',
        'uint8',
        'uint16',
        'uint32',
        'uint64',
        'union',
    )

    words = (
        'extension',
        'yang-version',
        'namespace',
        'prefix',
        'description',
        'import',
        'organization',
        'contact',
        'description',
        'revision',
        'typedef',
        'type',
        'enumeration',
        'range',
        'length',
        'grouping',
        'leaf',
        'leaf-list',
        'enum',
        'default',
        'key',
        'mandatory',
        'refine',
        'uses',
        'list',
        'container',
        'union',
        'value',
        'reference',
        'pattern',
    )

    # the yang keywords
    kw = dict((w, f'[{w}]') for w in words)
    # the yang module loaded
    kw['loaded'] = '[loaded]'
    # the root of the configuration
    kw['root'] = '[root]'
    # strings can be pattern but is assume to be a match otherwise, make it explicit
    kw['match'] = '[match]'

    ranges = {
        'int8': (0, pow(2, 8)-1),
        'int16': (0, pow(2, 16)-1),
        'int32': (0, pow(2, 32)-1),
        'int64': (0, pow(2, 64)-1),
        'uint8': (-pow(2, 7), pow(2, 7)-1),
        'uint16': (-pow(2, 7), pow(2, 15)-1),
        'uint32': (-pow(2, 7), pow(2, 31)-1),
        'uint64': (-pow(2, 7), pow(2, 64)-1),
    }

    namespaces = {
        'ietf': 'https://raw.githubusercontent.com/YangModels/yang/master/standard/ietf/RFC',
    }

    # initialised by load
    # this is a namespace / singleton, and should not be used as instance
    models = {}
    folder = ''

    @classmethod
    def load(cls, library, folder):
        cls.folder = folder
        if not cls.models:
            models = json.loads(open(library).read())

        for m in models['ietf-yang-library:modules-state']['module']:
            cls.models[m['name']] = m

    @classmethod
    def fetch_models(cls, folder):
        print('downloading models')

        for module in cls.models:
            cls.fetch_model(folder, module)

        print('done.\n')

    @classmethod
    def fetch_model(cls, folder, name):
        if not os.path.exists('models'):
            os.mkdir('models')

        if name not in cls.models:
            sys.exit(f'{module} imported but not defined in yang-library-data.json')

        module = cls.models[name]

        revision = module['revision']
        yang = f'{name}@{revision}.yang'
        save = f'{folder}/{name}.yang'

        if 'schema' in module:
            url = module['schema']

        elif 'namespace' in module:
            namespace = module['namespace'].split(':')
            site = cls.namespaces.get(namespace[1], '')
            if not site:
                raise RuntimeError('unimplemented namespace case')

            url = f"{site}/{yang}"
        else:
            raise RuntimeError('unimplemented yang-library case')

        if os.path.exists(save):
            write(f'üëå skipping {name} (already downloaded)')
            if cls._verify(name, save):
                write('\n')
                return

        write(f'üëÅÔ∏è  retrieve {name}@{revision} ({url})')

        try:
            urllib.request.urlretrieve(url, save)
            # indirect = urllib.request.urlopen(schema).read()
        except urllib.error.HTTPError as exc:
            write(f'\nü•∫ failure attempting to retrieve {url}\n{exc}')
            return

        if not cls._verify(name, save):
            sys.exit(f'\ninvalid yang content for {name}@{revision}')

        write(f'üëç retrieve {name}@{revision}\n')

    @staticmethod
    def _verify(name, save):
        # simple but should be enough
        write(f'üîç checking {name} for correct yaml')
        if not open(save).readline().startswith('module'):
            write(f'ü•µ not-yang {name} does not contain a yang module')
            return False
        return True

    @classmethod
    def clean_models(cls):
        print(f'cleaning {cls.folder}')
        for file in glob(f'{cls.folder}/*.yang'):
            print(f'cleanup: {file}')
            os.remove(file)
        print('done.\n')


class Lexer(object):
    ignore = (Token.Text, Token.Comment.Singleline)

    @staticmethod
    def formated(string):
        returned = ''
        for line in string.strip().split('\n'):
            line = line.strip()

            if line.endswith('+'):
                line = line[:-1].strip()
            if line.startswith('+'):
                line = line[1:].strip()

            if line and line[0] == line[-1]:
                if line[0] in ('"', "'"):
                    line = line[1:-1]
            returned += line
        return returned

    def __init__(self, yangfile):
        name = yangfile.split('/')[-1].split('.')[0]
        # the yang file parsed tokens (configuration block according to the syntax)
        self.tokens = []
        # the name of the module being parsed
        self.module = ''
        # module can declare a "prefix" (nickname), which can be used to make the syntax shorter
        self.prefix = ''
        # the parsed yang tree
        # - at the root are the namespace (the module names) and within
        #   * a key for all the typedef
        #   * a key for all the grouping
        #   * a key for the root of the configuration
        # - a key [loaded] with a list of the module loaded (first is the one parsed)
        # the names of all the configuration sections
        self.tree = {}
        # the current namespace (module) we are parsing
        self.ns = {}
        # where the grouping for this section are stored
        self.grouping = {}
        # where the typedef for this section are stored
        self.typedef = {}
        # where the configuration parsed is stored
        self.root = {}
        self.load(name, yangfile)

    def tokenise(self, name):
        lexer = yanglexer.YangLexer()
        content = open(name).read()
        tokens = lexer.get_tokens(content)
        return [(t, n) for (t, n) in tokens if t not in self.ignore]

    def unexpected(self, string):
        pprint.pprint(f'unexpected data: {string}')
        for t in self.tokens[:15]:
            print(t)
        breakpoint()
        pass

    def pop(self, what=None, expected=None):
        token, string = self.tokens[0]
        if what is not None and not str(token).startswith(str(what)):
            self.unexpected(string)
        if expected is not None and string.strip() != expected:
            self.unexpected(string)
        self.tokens.pop(0)
        return string

    def peek(self, position, ponctuation=None):
        token, string = self.tokens[position]
        # the self includes a last ' '
        if ponctuation and ponctuation != token:
            self.unexpected(string)
        return token, string.rstrip()

    def skip_keyword_block(self, name):
        count = 0
        while True:
            t, v = self.tokens.pop(0)
            if t != Token.Punctuation:
                continue
            if v.strip() == '{':
                count += 1
            if v.strip() == '}':
                count -= 1
            if not count:
                break

    def set_subtrees(self):
        """
        to make the core more redeable the tree[module] structure
        is presented as subtrees, this reset all the subtree
        for the current module
        """
        self.ns = self.tree[self.module]
        self.grouping = self.ns[yang.kw['grouping']]
        self.typedef = self.ns[yang.kw['typedef']]
        self.root = self.ns[yang.kw['root']]

    def imports(self, module, prefix):
        """
        load, and if missing and defined download, a yang module

        module: the name of the yang module to find
        prefix: how it is called (prefix)
        """
        fname = os.path.join(yang.folder, module) + '.yang'
        if not os.path.exists(fname):
            yang.fetch_model('models', module)

        backup = (self.tokens, self.module, self.prefix)
        self.load(prefix, fname)
        self.tokens, self.module, self.prefix = backup
        self.set_subtrees()

    def load(self, module, fname):
        """
        add a new yang module/namespace to the tree
        this _function is used when initialising the
        root module, as it does not perform backups
        """
        self.tree.setdefault(yang.kw['loaded'], []).append(module)
        self.tokens = self.tokenise(fname)
        self.module = module
        self.prefix = module
        self.tree[module] = {
            yang.kw['typedef']: {},
            yang.kw['grouping']: {},
            yang.kw['root']: {},
        }
        self.set_subtrees()
        self.parse()

    def parse(self):
        self._parse([], self.root)
        return self.tree

    def _parse(self, inside, tree):
        while self.tokens:
            token, string = self.peek(0)

            if token == Token.Punctuation and string == '}':
                # it is clearer to pop it in the caller
                return

            self._parse_one(inside, tree, token, string)

    def _parse_one(self, inside, tree, token, string):
        if token == Token.Comment.Multiline:
            # ignore multiline comments
            self.pop(Token.Comment.Multiline)
            return

        if token == Token.Keyword.Namespace:
            self.pop(Token.Keyword.Namespace, 'module')
            self.pop(Token.Literal.String)
            self.pop(Token.Punctuation, '{')
            self._parse(inside, tree)
            self.pop(Token.Punctuation, '}')
            return

        if token != Token.Keyword or string not in yang.words:
            if ':' not in string:
                self.unknown(string, '')
                return

        self.pop(Token.Keyword, string)
        name = self.formated(self.pop(Token.Literal.String))

        if string == 'prefix':
            self.prefix = name
            self.pop(Token.Punctuation, ';')
            return

        if string in ('namespace', 'organization', 'contact', 'yang-version'):
            self.pop(Token.Punctuation, ';')
            return

        if string in ('revision', 'extension'):
            self.skip_keyword_block(Token.Punctuation)
            return

        if string in ('range', 'length'):
            self.pop(Token.Punctuation, ';')
            tree[yang.kw[string]] = [_ for _ in name.replace(' ', '').replace('..',' ').split()]
            return

        if string == 'import':
            token, string = self.peek(0, Token.Punctuation)
            if string == ';':
                self.pop(Token.Punctuation, ';')
                self.imports(name, name)
            if string == '{':
                self.pop(Token.Punctuation, '{')
                self.pop(Token.Keyword, 'prefix')
                prefix = self.formated(self.pop(Token.Literal.String))
                self.pop(Token.Punctuation, ';')
                self.pop(Token.Punctuation, '}')
                self.imports(name, prefix)
                return

        if string in ('description', 'reference'):
            self.pop(Token.Punctuation, ';')
            # XXX: not saved during debugging
            if DEBUG:
                return
            tree[yang.kw[string]] = name
            return

        if string in ('pattern', 'value', 'default', 'mandatory'):
            self.pop(Token.Punctuation, ';')
            tree[yang.kw[string]] = name
            return

        if string == 'key':
            self.pop(Token.Punctuation, ';')
            tree[yang.kw[string]] = name.split()
            return

        if string == 'typedef':
            self.pop(Token.Punctuation, '{')
            sub = self.typedef.setdefault(name, {})
            self._parse(inside + [name], sub)
            self.pop(Token.Punctuation, '}')
            return

        if string == 'enum':
            option = self.pop(Token.Punctuation)
            if option == ';':
                tree.setdefault(yang.kw[string], []).append(name)
                return
            if option == '{':
                sub = tree.setdefault(name, {})
                self._parse(inside + [name], sub)
                self.pop(Token.Punctuation, '}')
                return

        if string == 'type':
            # make sure the use module name and not prefix, as prefix is not global
            if ':' in name:
                module, typeref = name.split(':', 1)
                if module == self.prefix:
                    name = f'{self.module}:{typeref}'
                    module = self.module

                if module not in self.tree:
                    self.unexpected(f'referenced non-included module {name}')
            elif name not in yang.types:
                name = f'{self.module}:{name}'

            option = self.pop(Token.Punctuation)
            if option == ';':
                if name in yang.types:
                    tree.setdefault(yang.kw[string], {name: {}})
                    return

                if ':' not in name:
                    # not dealing with refine
                    # breakpoint()
                    tree.setdefault(yang.kw[string], {name: {}})
                    return

                tree.setdefault(yang.kw[string], {name: {}})
                return

            if option == '{':
                if name == 'union':
                    sub = tree.setdefault(yang.kw[string], {}).setdefault(name, [])
                    while True:
                        what, name = self.peek(0)
                        name = self.formated(name)
                        if name == 'type':
                            union_type = {}
                            self._parse_one(inside + [name], union_type, what, name)
                            sub.append(union_type[yang.kw['type']])
                            continue
                        if name == '}':
                            self.pop(Token.Punctuation, '}')
                            break
                        self.unexpected(f'did not expect this in an union: {what}')
                    return

                if name == 'enumeration':
                    sub = tree.setdefault(yang.kw[string], {}).setdefault(name, {})
                    self._parse(inside + [name], sub)
                    self.pop(Token.Punctuation, '}')
                    return

                if name in yang.types:
                    sub = tree.setdefault(yang.kw[string], {}).setdefault(name, {})
                    self._parse(inside + [name], sub)
                    self.pop(Token.Punctuation, '}')
                    return

                if ':' in name:
                    sub = tree.setdefault(yang.kw[string], {}).setdefault(name, {})
                    self._parse(inside + [name], sub)
                    self.pop(Token.Punctuation, '}')
                    return

        if string == 'uses':
            if name not in self.grouping:
                self.unexpected(f'could not find grouping calle {name}')
            tree.update(self.grouping[name])
            option = self.pop(Token.Punctuation)
            if option == ';':
                return
            if option == '{':
                sub = tree.setdefault(name, {})
                self._parse(inside + [name], sub)
                self.pop(Token.Punctuation, '}')
                return

        if string == 'grouping':
            self.pop(Token.Punctuation, '{')
            sub = self.grouping.setdefault(name, {})
            self._parse(inside + [name], sub)
            self.pop(Token.Punctuation, '}')
            return

        if string in ('container', 'list', 'refine', 'leaf', 'leaf-list'):
            self.pop(Token.Punctuation, '{')
            sub = tree.setdefault(name, {})
            self._parse(inside + [name], sub)
            self.pop(Token.Punctuation, '}')
            return

        self.unknown(string, name)

    def unknown(self, string, name):
        # catch unknown keyword so we can implement them
        pprint.pprint(self.ns)
        pprint.pprint('\n')
        pprint.pprint(string)
        pprint.pprint(name)
        pprint.pprint('\n')
        for t in self.tokens[:15]:
            pprint.pprint(t)
        breakpoint()
        # good luck!
        pass


# Used https://github.com/asottile/astpretty
# to understand how the python AST works
# Python 3.9 will have ast.unparse but until then
# https://github.com/simonpercivall/astunparse
# is used to generate code from the AST created

from ast import Module, Import, FunctionDef, arguments, arg, alias
from ast import Load, Call, Return, Name, Attribute, Constant, Param
from ast import Add, If, Compare, Gt, Lt, GtE, LtE, And, Or
from ast import BoolOp, UnaryOp, Not, USub

import astunparse


class Code(object):
    def __init__(self, tree):
        # the modules (import) required within the generated function
        self.imported = set()
        # type/function referenced in other types (union, ...)
        # which should therefore also be generated
        self.referenced = set()
        # the parsed yang as a tree
        self.tree = tree

    @staticmethod
    def _missing(**kargs):
        print(' '.join(f'{k}={v}' for k, v in kargs.items()))

        # this code path was not handled
        breakpoint()

    @staticmethod
    def _unique(name, counter={}):
        unique = counter.get(name, 0)
        unique += 1
        counter[name] = unique
        return f'{name}_{unique}'

    @staticmethod
    def _module(body):
        ast = Module(
            body=body,
        )
        return ast

    @staticmethod
    def _function(name, body):
        name = name.split(':')[-1].replace('-', '_')
        return [
            FunctionDef(
                name=name,
                args=arguments(
                    posonlyargs=[],
                    args=[arg(arg='value', annotation=None, type_comment=None)],
                    vararg=None,
                    kwonlyargs=[],
                    kw_defaults=[],
                    kwarg=None,
                    defaults=[],
                ),
                body=body,
                decorator_list=[],
                returns=None,
                type_comment=None,
            )
        ]

    @staticmethod
    def _return_boolean(value):
        return [
            Return(
                value=Constant(value=value, kind=None),
            )
        ]

    def _if_pattern(self, pattern):
        self.imported.add('re')
        return [
            If(
                test=UnaryOp(
                    op=Not(),
                    operand=Call(
                        func=Attribute(
                            value=Name(id='re', ctx=Load()),
                            attr='match',
                            ctx=Load(),
                        ),
                        args=[
                            Constant(value=pattern, kind=None),
                            Name(id='value', ctx=Load()),
                        ],
                        keywords=[],
                    ),
                ),
                body=[
                    Return(
                        value=Constant(value=False, kind=None),
                    ),
                ],
                orelse=[],
            ),
        ]

    def _if_length(self, min, max):
        self.imported.add('re')
        return [
            If(
                test=Compare(
                    left=Constant(value=min, kind=None),
                    ops=[
                        Gt(),
                        Gt(),
                    ],
                    comparators=[
                        Call(
                            func=Name(id='len', ctx=Load()),
                            args=[Name(id='value', ctx=Load())],
                            keywords=[],
                        ),
                        Constant(value=max, kind=None),
                    ],
                ),
                body=[
                    Return(
                        lineno=4,
                        col_offset=8,
                        end_lineno=4,
                        end_col_offset=20,
                        value=Constant(value=False, kind=None),
                    ),
                ],
                orelse=[],
            ),
        ]

    def _iter_if_string(self, node):
        for what, sub in node.items():
            if what == yang.kw['pattern']:
                yield self._if_pattern(sub)
                continue

            if what == yang.kw['match']:
                self._missing(if_type=what, node=node)
                continue

            if what == yang.kw['length']:
                yield self._if_length(*sub)
                continue

            self._missing(if_type=what, node=node)

    @staticmethod
    def _if_digit():
        return [
            If(
                test=UnaryOp(
                    op=Not(),
                    operand=Call(
                        func=Attribute(
                            value=Name(id='value', ctx=Load()),
                            attr='isdigit',
                            ctx=Load(),
                        ),
                        args=[],
                        keywords=[],
                    ),
                ),
                body=[
                    Return(
                        value=Constant(value=False, kind=None),
                    ),
                ],
                orelse=[],
            )
        ]

    @staticmethod
    def _if_lt(value):
        if value >= 0:
            comparators = [
                Constant(value=value, kind=None)
            ]
        else:
            comparators = [
                UnaryOp(
                    op=USub(),
                    operand=Constant(value=abs(value), kind=None),
                ),
            ]

        return [
            If(
                test=Compare(
                    left=Call(
                        func=Name(id='int', ctx=Load()),
                        args=[Name(id='value', ctx=Load())],
                        keywords=[],
                    ),
                    ops=[Lt()],
                    comparators=comparators,
                    keywords=[],
                ),
                body=[
                    Return(
                        value=Constant(value=False, kind=None),
                    ),
                ],
                orelse=[],
            )
        ]

    @staticmethod
    def _if_gt(value):
        if value >= 0:
            comparators = [
                Constant(value=value, kind=None)
            ]
        else:
            comparators = [
                UnaryOp(
                    op=USub(),
                    operand=Constant(value=abs(value), kind=None),
                ),
            ]
        return [
            If(
                test=Compare(
                    left=Call(
                        func=Name(id='int', ctx=Load()),
                        args=[Name(id='value', ctx=Load())],
                        keywords=[],
                    ),
                    ops=[Gt()],
                    comparators=comparators,
                ),
                body=[
                    Return(
                        value=Constant(value=False, kind=None),
                    ),
                ],
                orelse=[],
            )
        ]

    def _if_range(self, minimum, maximum):
        return self._if_digit() + self._if_lt(minimum) + self._if_gt(maximum)

    def _union(self, names, tests):
        funcs = []
        values = []

        for test in tests:
            name = self._unique(names.pop(0))
            name = name.replace(':', '__').replace('-', '_')
            yield self._function(name, test + self._return_boolean(True))

            values += [
                UnaryOp(
                    op=Not(),
                    operand=Call(
                        func=Name(id=name, ctx=Load()),
                        args=[Name(id='value', ctx=Load())],
                        keywords=[],
                    ),
                ),
            ]

        yield funcs + [
            If(
                test=BoolOp(
                    op=And(),
                    values=values,
                ),
                body=[
                    Return(
                        value=Constant(value=False, kind=None),
                    ),
                ],
                orelse=[],
            ),
        ]

    def _imports(self):
        returned = []
        for imported in self.imported:
            returned.append(
                Import(
                    names=[alias(name='re', asname=None)],
                )
            )
        return returned

    def _type(self, keyword, node):
        if keyword == 'union':
            names = []
            funcs = []

            for each in node:
                print(each)
                for what, sub in each.items():
                    names.append(what.replace('-', '_'))
                    funcs.append(self._type(what, sub))

            return list(self._union(names, funcs))

        if keyword in ('int8', 'int16', 'int16', 'int32', 'uint8', 'uint16', 'uint16', 'uint32'):
            # not dealing with refine
            minimum, maximum = yang.ranges[keyword]
            return self._if_range(minimum, maximum)

        if keyword == 'string':
            return list(self._iter_if_string(node))

        if ':' in keyword:
            ns, name = keyword.split(':', 1)
            return list(self._generate(ns, name))

        self._missing(keyword=keyword, node=node)

    def _iter(self, node):
        for keyword, content in node.items():
            yield self._type(keyword, content)

    def _generate(self, module, only):
        td = self.tree[module][yang.kw['typedef']]

        for name in td:
            if only and only != name:
                continue
            body = list(self._iter(td[name][yang.kw['type']]))
            print(name)
            print(body)
            print('')
            yield self._function(name, body + self._return_boolean(True))

    def generate(self, module, only=''):
        generated = self._imports()
        generated += list(self._generate(module, only))
        while self.referenced:
            module, check = self.referenced.pop(0)
            generated += list(self._generate(module, check))
        return self._module(generated)


class Conf(object):
    intro = '# yang model structure and validation\n# autogenerate by exabgp\n\n'
    variable = '{name} = {data}\n'

    def __init__(self, fname):
        self.fname = fname
        self.dicts = []
        self.codes = []

    def add_dict(self, name, data):
        self.dicts.append((name, data))

    def add_code(self, block):
        self.codes.append(block)

    def _generate(self):
        returned = self.intro
        for name, data in self.dicts:
            returned += self.variable.format(name=name, data=data)
            returned += '\n'
        for section in self.codes:
            returned += section
            returned += '\n'
        return returned

    def save(self):
        print(f'generating {self.fname}')
        with open(self.fname, 'w') as w:
            w.write(self._generate())

    def output(self):
        for name, data in self.dicts:
            pprint.pprint(name)
            pprint.pprint(data)
        for section in self.codes:
            print(section)


def main():
    folder = os.path.dirname(__file__)
    os.chdir(os.path.abspath(folder))

    library = 'yang-library-data.json'
    module = 'exabgp'
    models = 'models'
    fname = '{module}-yang.py'

    conf = Conf(fname)

    yang.load(library, models)
    tree = Lexer(f'{module}.yang').parse()

    conf.add_dict('model', tree)
    # conf.output()

    code = Code(tree)
    ast = code.generate(module)
    block = astunparse.unparse(ast)
    conf.add_code(block)

    conf.output()
    # # conf.save()


if __name__ == "__main__":
    main()
