#!/usr/bin/env python3
# encoding: utf-8
"""
cache.py

Created by Thomas Mangin
Copyright (c) 2013-2017 Exa Networks. All rights reserved.
License: 3-clause BSD. (See the COPYRIGHT file)
"""

import os
import re
import sys
import glob
import time
import signal
import argparse
import subprocess
from enum import Enum

INTERPRETER = os.environ.get('__PYVENV_LAUNCHER__', sys.executable)


def color(prefix, suffix):
    def code(value):
        return f'\033[{value}m'
    return code(prefix) + code(suffix)


class Port:
    base = 1790

    @classmethod
    def get(cls):
        current = cls.base
        cls.base += 1
        return current


class Path:
    PROGRAM = os.path.realpath(__file__)
    ROOT = os.path.abspath(os.path.join(os.path.dirname(PROGRAM), os.path.join('..', '..')))
    SRC = os.path.join(ROOT, 'src')

    ETC = os.path.join(ROOT, 'etc', 'exabgp')
    EXABGP = os.path.join(ROOT, 'sbin', 'exabgp')
    BGP = os.path.join(ROOT, 'qa', 'sbin', 'bgp')
    CI = os.path.join(os.path.join(ROOT, 'qa', 'ci'))
    JSON = os.path.join(os.path.join(ROOT, 'qa', 'json'))
    ALL_CI = glob.glob(os.path.join(CI, '*.ci'))
    ALL_CI.sort()

    @staticmethod
    def etc(fname):
        return os.path.abspath(os.path.join(Path.ETC, fname))

    @staticmethod
    def ci(fname, ext):
        return os.path.abspath(os.path.join(Path.CI, fname) + '.' + ext)

    @classmethod
    def validate(cls):
        if not os.path.isdir(cls.ETC):
            sys.exit('could not find etc folder')

        if not os.path.isdir(cls.CI):
            sys.exit('could not find tests in the qa/ci folder')

        if not os.path.isdir(cls.JSON):
            sys.exit('could not find the tests in qa/json')

        if not os.path.isfile(cls.EXABGP):
            sys.exit('could not find exabgp')

        if not os.path.isfile(cls.BGP):
            sys.exit('could not find the sequence daemon')


class Sequence:
    def __init__(self):
        self._next = 0

    def increase(self):
        self._next += 1
        return self._next - 1

    def current(self):
        return self._next


class Exec(object):
    def __init__(self, check=b'successful'):
        self.stdout = b''
        self.stderr = b''
        self._check = check
        self._process = None

    def run(self, command):
        self._process = subprocess.Popen(
            command,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
        )
        return self

    def success(self):
        self.terminate()
        return self._check in self.stdout or self._check in self.stderr

    def ready(self):
        try:
            signal.alarm(1)
            polled = self._process.poll()
            signal.alarm(0)
        except Alarm:
            return False
        except (OSError, ValueError):
            return True
        if polled is None:
            return False
        return True

    def collect(self):
        if self.stdout or self.stderr:
            return
        try:
            signal.alarm(1)
            self.stdout, self.stderr = self._process.communicate()
            signal.alarm(0)
        except ValueError:  # I/O operation on closed file
            pass
        except Alarm:
            pass
        # self.stdout = self.stdout.replace('\\n', '\n')
        # self.stderr = self.stderr.replace('\\n', '\n')

    def terminate(self):
        try:
            self._process.send_signal(signal.SIGTERM)
        except OSError:  # No such process, Errno 3
            pass
        self.collect()

    def __del__(self):
        self.terminate


State = Enum('State', 'NONE STARTING RUNNING FAIL SUCCESS SKIP')


class Test(Exec):
    _listing = \
        '0123456789' + \
        'ABCDEFGHIJKLMNOPQRSTUVWXYZ' + \
        'abcdefghijklmnopqrstuvwxyz' + \
        'αβγδεζηθικλμνξοπρςστυφχψω'

    def __init__(self, nick, name):
        super().__init__()
        self.nick = nick
        self.name = name
        self.conf = dict()
        self.files = []
        self.state = State.NONE

    @classmethod
    def new(cls, number, name):
        nick = cls._listing[number]
        return cls(nick, name)

    def skip(self):
        self.state = State.SKIP

    def activate(self, test):
        if test:
            self.state = State.NONE
            return self
        else:
            self.state = State.SKIP
            return None

    def is_active(self):
        return self.state not in (State.SKIP, State.FAIL, State.SUCCESS)

    def setup(self):
        if self.state == State.NONE:
            self.state = State.STARTING
            return
        if self.state == State.STARTING:
            self.state = State.RUNNING
            return

    def colored(self):
        if self.state == State.NONE:
            return color(0, 30) + self.nick  # BLACK
        if self.state == State.STARTING:
            return color(1, 30) + self.nick  # GRAY
        if self.state == State.RUNNING:
            return color(0, 0) + self.nick  # NORMAL
        if self.state == State.FAIL:
            return color(0, 91) + self.nick  # RED
        if self.state == State.SUCCESS:
            return color(1, 92) + '✓'        # GREEN
        if self.state == State.SKIP:
            return color(0, 34) + '✖'        # BLUE

    def result(self, success):
        if success:
            self.state = State.SUCCESS
        else:
            self.state = State.FAIL
        return success


class Tests:
    def __init__(self):
        self._sequence = Sequence()
        self._from_code = {}
        self._from_nick = {}
        self._nl = 3

    def new(self, name):
        code = self._sequence.increase()
        test = Test.new(code, name)
        self._from_code[code] = test
        self._from_nick[test.nick] = test
        return test

    def select(self, nick):
        if not nick:
            return None
        activated = None
        for test in self._from_code.values():
            activated = test.activate(test.nick == nick) or activated
        return activated

    def all(self):
        for test in self._from_code.values():
            test.state = State.SKIP

        for test in self._from_code.values():
            if test.state == State.SKIP:
                test.state = State.NONE
            test.result(self.run_active(parsed.timeout))

    def selected(self):
        return [_ for _ in self._from_code.values() if _.is_active()]

    def _iterate(self):
        last = self._sequence.current()
        step = last // self._nl
        if last % self._nl:
            step += 1
        nl = 1

        for c in range(0, step):
            for r in range(self._nl):
                n = c + (r*step)
                if n >= last:
                    return
                test = self._from_code[n]
                yield test.nick, test.name, not (nl % self._nl)
                nl += 1

    def listing(self):
        sys.stdout.write('\n')
        sys.stdout.write('The available tests are:\n')
        sys.stdout.write('\n')
        for nick, name, nl in self._iterate():
            sys.stdout.write(f' {nick:2} {name:25}')
            sys.stdout.write('\n' if nl else '')
        sys.stdout.write('\n')
        sys.stdout.flush()

    def display(self):
        for test in self._from_code.values():
            sys.stdout.write(' %s' % test.colored())
        sys.stdout.write('%s\r' % color(0, 0))
        sys.stdout.flush()


class TestPacketGeneration(Tests):
    API = re.compile(r'^\s*run\s+(.*)\s*?;\s*?$')
    _content = {}
    _tests = []

    def __init__(self):
        super().__init__()

        for filename in Path.ALL_CI:
            name = os.path.basename(filename)[:-3]
            test = self.new(name)
            with open(filename, 'r') as reader:
                content = reader.readline()
            test.conf['confs'] = [Path.etc(_) for _ in content.split()]
            test.conf['ci'] = Path.ci(name, 'ci')
            test.conf['msg'] = Path.ci(name, 'msg')
            test.conf['port'] = Port.get()
            test.files.extend(test.conf['confs'])
            test.files.append(test.conf['ci'])
            test.files.append(test.conf['msg'])

            for f in test.conf['confs']:
                with open(f) as reader:
                    for line in reader:
                        found = self.API.match(line)
                        if not found:
                            continue
                        name = found.group(1)
                        if not name.startswith('/'):
                            name = Path.etc(name)
                        if name not in test.files:
                            test.files.append(name)

    def explain(self, index):
        template = '\n'
        template += 'exabgp\n'
        template += '-'*55 + '\n\n'
        template += '%(client)s\n\n\n'
        template += 'bgp deamon\n'
        template += '-'*55 + '\n\n'
        template += '%(server)s\n\n\n'
        template += 'The following extra configuration options could be used\n'
        template += '-'*55 + '\n\n'
        template += 'export exabgp_debug_rotate=true\n'
        template += 'export exabgp_debug_defensive=true\n'

        print(template % {
            'client': self.client(index),
            'server': self.server(index),
        })
        sys.exit(1)

    def client(self, index):
        test = self.select(index)
        if not test:
            sys.exit("no such test")

        config = {
            'env': ' \\\n  '.join(
                [
                    'exabgp_tcp_once=true',
                    'exabgp_api_cli=false',
                    'exabgp_debug_rotate=true',
                    'exabgp_debug_configuration=true',
                    'exabgp_tcp_bind=\'\'',
                    'exabgp_tcp_port=%d' % test.conf['port'],
                    'INTERPRETER=%s' % INTERPRETER,
                ]
            ),
            'exabgp': Path.EXABGP,
            'confs': ' \\\n    '.join(test.conf['confs']),
        }
        return 'env \\\n  %(env)s \\\n   %(exabgp)s -d -p \\\n    %(confs)s' % config

    def server(self, index):
        test = self.select(index)

        if not test:
            sys.exit("no such test")

        config = {
            'env': ' \\\n  '.join(['exabgp_tcp_port=%d' % test.conf['port'],]),
            'interpreter': INTERPRETER,
            'bgp': Path.BGP,
            'msg': test.conf['msg'],
        }

        return 'env \\\n  %(env)s \\\n  %(interpreter)s %(bgp)s --view \\\n    %(msg)s' % config

    def run_active(self, timeout):
        success = True
        client = dict()

        for test in self.selected():
            test.setup()
            self.display()
            test.run([
                sys.argv[0],
                'server', test.nick,
                '--port', f'{test.conf["port"]}'
            ])
            time.sleep(0.005)

        time.sleep(0.02)

        for test in self.selected():
            test.setup()
            self.display()
            client[test.nick] = Exec().run([
                sys.argv[0],
                'client', test.nick,
                '--port', f'{test.conf["port"]}'
            ])
            time.sleep(0.005)

        exit_time = time.time() + timeout

        running = set(test for test in self.selected())

        while running and time.time() < exit_time:
            self.display()
            for test in list(running):
                if not test.ready():
                    continue
                if not client[test.nick].ready():
                    continue
                running.remove(test)
                client[test.nick].terminate()
                success = test.result(test.success()) and success
                self.display()
            time.sleep(0.1)

        self.display()
        return success


class Alarm(Exception):
    pass


def alarm_handler(number, frame):  # pylint: disable=W0613
    raise Alarm()


if __name__ == '__main__':
    Path.validate()
    tests = TestPacketGeneration()

    parser = argparse.ArgumentParser(description='The BGP swiss army knife of networking functional testing tool')
    subparsers = parser.add_subparsers()

    def all(parsed):
        tests.all()
        sys.stdout.write('\n')

    sub = subparsers.add_parser('all', help='run all available test')
    sub.add_argument('--timeout', help='timeout for test failure', type=int, default=60)
    sub.add_argument('--port', help='base port to use', type=int, default=1790)
    sub.set_defaults(func=all)

    def run(parsed):
        tests.select(parsed.test)
        tests.run_active(parsed.timeout)
        sys.stdout.write('\n')

    sub = subparsers.add_parser('run', help='run a particular test')
    sub.add_argument('test', help='name of the test to run', nargs='?', default=None)
    sub.add_argument('--timeout', help='timeout for test failure', type=int, default=60)
    sub.add_argument('--port', help='base port to use', type=int, default=1790)
    sub.add_argument('--steps', help='number of test to run simultaneously', type=int, default=0)
    sub.set_defaults(func=run)

    def client(parsed):
        command = tests.client(parsed.test)
        print(f'> {command}')
        if not parsed.dry:
            sys.exit(os.system(command))
        sys.exit(0)

    sub = subparsers.add_parser('client', help='start the client for a specific test')
    sub.add_argument('test', help='name of the test to run')
    sub.add_argument('-d', '--dry', help='show what command would be run but does nothing', action='store_true')
    sub.add_argument('--timeout', help='timeout for test failure', type=int, default=60)
    sub.add_argument('--port', help='base port to use', type=int, default=1790)
    sub.set_defaults(func=client)

    def server(parsed):
        command = tests.server(parsed.test)
        print(f'> {command}')
        if not parsed.dry:
            sys.exit(os.system(command))
        sys.exit(0)

    sub = subparsers.add_parser('server', help='start the server for a specific test')
    sub.add_argument('test', help='name of the test to run')
    sub.add_argument('-d', '--dry', help='show what command would be run but does nothing', action='store_true')
    sub.add_argument('--timeout', help='timeout for test failure', type=int, default=60)
    sub.add_argument('--port', help='base port to use', type=int, default=1790)
    sub.set_defaults(func=server)

    def explain(parsed):
        tests.explain(parsed.test)
        sys.exit(0)

    sub = subparsers.add_parser('explain', help='show what command for a test are run')
    sub.add_argument('test', help='name of the test to explain')
    sub.add_argument('--timeout', help='timeout for test failure', type=int, default=60)
    sub.add_argument('--port', help='base port to use', type=int, default=1790)
    sub.set_defaults(func=explain)

    def edit(parsed):
        test = tests.select(parsed.test) or Test('', '')
        if not test.files:
            sys.exit('no such test')
        editor = os.environ.get('EDITOR', 'vi')
        os.system('%s %s' % (editor, ' '.join(test.files)))
        sys.exit(0)

    sub = subparsers.add_parser('edit', help='start $EDITOR to edit a specific test')
    sub.add_argument('test', help='name of the test to edit')
    sub.set_defaults(func=edit)

    def decode(parsed):
        test = tests.get(parsed.test)
        command = '%s decode %s  "%s"' % (Path.EXABGP, test['confs'][0], ''.join(parsed.payload))
        print('> %s' % command)
        os.system(command)
        sys.exit(0)

    sub = subparsers.add_parser('decode', help='use the test configuration to decode a packet')
    sub.add_argument('test', help='name of the test to use to know the BGP configuration')
    sub.add_argument('payload', nargs='+', help='the hexadecimal representation of the packet')
    sub.set_defaults(func=decode)

    def listing(parsed):
        TestPacketGeneration().listing()

    sub = subparsers.add_parser('list', help='list all functional test available')
    sub.set_defaults(func=listing)

    parsed = parser.parse_args()
    if vars(parsed):
        parsed.func(parsed)
    else:
        parser.print_help()
