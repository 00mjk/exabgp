#!/usr/bin/env python3

import re
import os
import sys
import json
import shutil
import pprint
import urllib.request
from glob import glob

from pygments.token import Token
from yanglexer import yanglexer

from yangson.datamodel import DataModel


def write(string):
    if not string.startswith('\n'):
        fill = ' ' * shutil.get_terminal_size().columns
        sys.stdout.write(f'\r{fill}\r')
    sys.stdout.write(f'{string}')
    sys.stdout.flush()


class yang:
    types = (
        'binary',
        'bits',
        'boolean',
        'decimal64',
        'empty',
        'enumeration',
        'identityref',
        'instance-identifier',
        'int8',
        'int16',
        'int32',
        'int64',
        'leafref',
        'string',
        'uint8',
        'uint16',
        'uint32',
        'uint64',
        'union',
    )

    words = (
        'extension',
        'yang-version',
        'namespace',
        'prefix',
        'description',
        'import',
        'organization',
        'contact',
        'description',
        'revision',
        'typedef',
        'type',
        'enumeration',
        'range',
        'length',
        'grouping',
        'leaf',
        'leaf-list',
        'enum',
        'default',
        'key',
        'mandatory',
        'refine',
        'uses',
        'list',
        'container',
        'union',
        'value',
        'reference',
        'pattern',
    )

    kw = dict((w, f'[{w}]') for w in words)

    ranges = {
        'int8': (0, (2 ^ 8)-1),
        'int16': (0, (2 ^ 16)-1),
        'int32': (0, (2 ^ 32)-1),
        'int64': (0, (2 ^ 64)-1),
        'uint8': (-(2 ^ 7), (2 ^ 7)-1),
        'uint16': (-(2 ^ 7), (2 ^ 15)-1),
        'uint32': (-(2 ^ 7), (2 ^ 31)-1),
        'uint64': (-(2 ^ 7), (2 ^ 64)-1),
    }

    namespaces = {
        'ietf': 'https://raw.githubusercontent.com/YangModels/yang/master/standard/ietf/RFC',
    }

    # initialised by load
    # this is a namespace / singleton, and should not be used as instance
    models = {}
    folder = ''

    @classmethod
    def load(cls, library, folder):
        cls.folder = folder
        if not cls.models:
            models = json.loads(open(library).read())

        for m in models['ietf-yang-library:modules-state']['module']:
            cls.models[m['name']] = m

    @classmethod
    def fetch_models(cls, folder):
        print('downloading models')

        for module in cls.models:
            cls.fetch_model(folder, module)

        print('done.\n')

    @classmethod
    def fetch_model(cls, folder, name):
        if not os.path.exists('models'):
            os.mkdir('models')

        if name not in cls.models:
            sys.exit(f'{module} imported but not defined in yang-library-data.json')

        module = cls.models[name]

        breakpoint()
        revision = module['revision']
        yang = f'{name}@{revision}.yang'
        save = f'{folder}/{name}.yang'

        if 'schema' in module:
            url = module['schema']

        elif 'namespace' in module:
            namespace = module['namespace'].split(':')
            site = cls.namespaces.get(namespace[1], '')
            if not site:
                raise RuntimeError('unimplemented namespace case')

            url = f"{site}/{yang}"
        else:
            raise RuntimeError('unimplemented yang-library case')

        if os.path.exists(save):
            write(f'üëå skipping {name} (already downloaded)')
            if cls._verify(name, save):
                write('\n')
                return

        write(f'üëÅÔ∏è  retrieve {name}@{revision} ({url})')

        try:
            urllib.request.urlretrieve(url, save)
            # indirect = urllib.request.urlopen(schema).read()
        except urllib.error.HTTPError as exc:
            write(f'\nü•∫ failure attempting to retrieve {url}\n{exc}')
            return

        if not cls._verify(name, save):
            sys.exit(f'\ninvalid yang content for {name}@{revision}')

        write(f'üëç retrieve {name}@{revision}\n')

    @staticmethod
    def _verify(name, save):
        # simple but should be enough
        write(f'üîç checking {name} for correct yaml')
        if not open(save).readline().startswith('module'):
            write(f'ü•µ not-yang {name} does not contain a yang module')
            return False
        return True

    @classmethod
    def clean_models(cls):
        print(f'cleaning {cls.folder}')
        for file in glob(f'{cls.folder}/*.yang'):
            print(f'cleanup: {file}')
            os.remove(file)
        print('done.\n')


replace = re.compile('\n\t')


class Lexer(object):
    ignore = (Token.Text, Token.Comment.Singleline)

    @staticmethod
    def formated(string):
        s = string.strip()
        if s and s[0] == s[-1]:
            if s[0] in ('"', "'"):
                s = s[1:-1]
        s = re.sub(r'\n\t*\s*', ' ', s)
        return s

    def __init__(self, yangfile):
        self.prefix = ''
        self.name = yangfile.split('/')[-1].split('.')[0]
        self.tree = {
            self.name: {
                yang.kw['typedef']: {}
            }
        }
        self.root = self.tree[self.name]
        self.tokens = self.tokenise(yangfile)

    def tokenise(self, name):

        lexer = yanglexer.YangLexer()
        content = open(name).read()
        tokens = lexer.get_tokens(content)
        return [(t, n) for (t, n) in tokens if t not in self.ignore]

    def unexpected(self, string):
        pprint.pprint(f'unexpected data: {string}')
        for t in self.tokens[:15]:
            print(t)
        breakpoint()
        pass

    def pop(self, what, expected=None):
        token, string = self.tokens[0]
        if not str(token).startswith(str(what)):
            self.unexpected(string)
        if expected is not None and string.strip() != expected:
            self.unexpected(string)
        self.tokens.pop(0)
        return string

    def peek(self, position, ponctuation=None):
        token, string = self.tokens[position]
        # the self includes a last ' '
        if ponctuation and ponctuation != token:
            self.unexpected(string)
        return token, string.rstrip()

    def skip_keyword_block(self, name):
        count = 0
        while True:
            t, v = self.tokens.pop(0)
            if t != Token.Punctuation:
                continue
            if v.strip() == '{':
                count += 1
            if v.strip() == '}':
                count -= 1
            if not count:
                break

    def imports(self, module, prefix):
        fname = os.path.join(yang.folder, module) + '.yang'
        if not os.path.exists(fname):
            yang.fetch_model('models', module)
        tokens = self.tokens
        root = self.root

        self.tree[prefix] = {
            yang.kw['typedef']: {}
        }
        self.root = self.tree[prefix]
        self.tokens = self.tokenise(fname)
        self.parse()

        self.tokens = tokens
        self.root = root

    def parse(self, tree=None):
        if tree is None:
            tree = self.root
        self._parse([], tree)
        return self.root

    def _parse(self, inside, tree):
        while self.tokens:
            token, string = self.peek(0)

            if token == Token.Punctuation and string == '}':
                # it is clearer to pop it in the caller
                return

            if token == Token.Comment.Multiline:
                # ignore multiline comments
                self.pop(Token.Comment.Multiline)
                continue

            if token == Token.Keyword.Namespace:
                self.pop(Token.Keyword.Namespace, 'module')
                self.pop(Token.Literal.String)
                self.pop(Token.Punctuation, '{')
                self._parse(inside, tree)
                self.pop(Token.Punctuation, '}')
                continue

            if token != Token.Keyword or string not in yang.words:
                if ':' not in string:
                    self.unknown(string, '')
                    continue

            self.pop(Token.Keyword, string)
            name = self.formated(self.pop(Token.Literal.String))

            if string == 'prefix':
                self.prefix = name
                self.pop(Token.Punctuation, ';')
                continue

            if string in ('namespace', 'organization', 'contact', 'yang-version'):
                self.pop(Token.Punctuation, ';')
                continue

            if string in ('revision', 'extension'):
                self.skip_keyword_block(Token.Punctuation)
                continue

            if string in ('range', 'length'):
                self.pop(Token.Punctuation, ';')
                tree[yang.kw[string]] = [_ for _ in name.replace(' ', '').replace('..',' ').split()]
                continue

            if string == 'import':
                token, string = self.peek(0, Token.Punctuation)
                if string == ';':
                    self.pop(Token.Punctuation, ';')
                    self.imports(name, name)
                if string == '{':
                    self.pop(Token.Punctuation, '{')
                    self.pop(Token.Keyword, 'prefix')
                    prefix = self.formated(self.pop(Token.Literal.String))
                    self.pop(Token.Punctuation, ';')
                    self.pop(Token.Punctuation, '}')
                    self.imports(name, prefix)
                    continue

            if string in ('description', 'pattern', 'reference', 'value', 'default', 'mandatory'):
                self.pop(Token.Punctuation, ';')
                tree[yang.kw[string]] = name
                continue

            if string == 'key':
                self.pop(Token.Punctuation, ';')
                tree[yang.kw[string]] = name.split()
                continue

            if string == 'typedef':
                self.pop(Token.Punctuation, '{')
                sub = tree.setdefault(yang.kw[string], {}).setdefault(name, {})
                self._parse(inside + [name], sub)
                self.pop(Token.Punctuation, '}')
                continue

            if string == 'enum':
                option = self.pop(Token.Punctuation)
                if option == ';':
                    tree.setdefault(yang.kw[string], []).append(name)
                    continue
                if option == '{':
                    sub = tree.setdefault(name, {})
                    self._parse(inside + [name], sub)
                    self.pop(Token.Punctuation, '}')
                    continue

            if string == 'type':
                option = self.pop(Token.Punctuation)
                if option == ';':
                    if ':' in name:
                        prefix, suffix = name.split(':', 1)
                        if prefix == self.prefix:
                            name = suffix
                            tree.setdefault(yang.kw[string], []).append(name)
                            continue

                        if prefix not in self.tree:
                            self.unexpected(f'referenced non-included module {name}')

                        if suffix not in self.tree[prefix].get(yang.kw['typedef'], {}):
                            self.unexpected(f'referenced a undefined typedef {name}')

                        self.root[yang.kw['typedef']][name] = self.tree[prefix][yang.kw['typedef']][suffix]
                        tree.setdefault(yang.kw[string], []).append(name)
                        continue

                    tree.setdefault(yang.kw[string], []).append(name)
                    continue

                if option == '{':
                    if name in ('union', 'enumeration') or ':' in name or name in yang.types:
                        sub = tree.setdefault(yang.kw[string], {}).setdefault(name, {})
                        self._parse(inside + [name], sub)
                        self.pop(Token.Punctuation, '}')
                        continue

            if string == 'uses':
                tree.update(self.root['grouping'][name])
                option = self.pop(Token.Punctuation)
                if option == ';':
                    continue
                if option == '{':
                    sub = tree.setdefault(name, {})
                    self._parse(inside + [name], sub)
                    self.pop(Token.Punctuation, '}')
                    continue

            if string == 'grouping':
                self.pop(Token.Punctuation, '{')
                sub = self.root.setdefault('grouping', {}).setdefault(name, {})
                self._parse(inside + [name], sub)
                self.pop(Token.Punctuation, '}')
                continue

            if string in ('container', 'list', 'refine', 'leaf', 'leaf-list'):
                self.pop(Token.Punctuation, '{')
                sub = tree.setdefault(name, {})
                self._parse(inside + [name], sub)
                self.pop(Token.Punctuation, '}')
                continue

            self.unknown(string, name)

    def unknown(self, string, name):
        # catch unknown keyword so we can implement them
        pprint.pprint(self.root)
        pprint.pprint('\n')
        pprint.pprint(string)
        pprint.pprint(name)
        pprint.pprint('\n')
        for t in self.tokens[:15]:
            pprint.pprint(t)
        breakpoint()
        # good luck!
        pass


def make_tree(yang, python):
    root = Lexer(yang).parse()
    print(pprint.pformat(root))
    print()

    print(f'generating {python}')
    with open(python, 'w') as w:
        w.write('# yang model converted to dict\n')
        w.write('\n')
        w.write('model = ')
        w.write(str(root))
        w.write('\n')


def main():
    folder = os.path.dirname(__file__)
    os.chdir(os.path.abspath(folder))

    yang.load('yang-library-data.json', 'models')
    make_tree('exabgp.yang', 'model.py')


if __name__ == "__main__":
    main()
